// 输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数
// 例如，1~13中包含1的数字有1、10、11、12、13因此共出现6次

// 但是当数值比较大的时候，容易超时


function NumberOf1Between1AndN_Solution(n)
{
  // write code here
  let count = 0
  for(let i = 1; i <= n;i++) {
    const str = String(i);
    const res = str.match(/1/g)
    count+= res ?  res.length: 0;
  }
  return count
}




// console.log(NumberOf1Between1AndN_Solution(13));



// 应该是仅仅数 1 的个数

// 计算某一位的 的 1 出现的情况 ，以下为分析 十位的情况
//
// case 1: cur=0
// 2  3   0  4
// 千位和百位可以选00 01 02....22  十位可以取到1( 形如[00|01..|22]1[0-9] 都是<2304 ) 个位可以选0-9  共有 23 * 10 中排列
// 当千位和百位取23,如果十位取1 那就是形如 231[0-9] > 2304,所以当千位和百位取23，十位只能能取0，个位取0-4即 2300 2301 2302 2303 2304
// 但是2301不应该算进来，这个1是 单独  出现在个位的（而11，121,111这种可以被算多次）

// 计算公式为当前位置的    权重 * 高位   23 * 10


// case 2: cur=1
// 2  3  1  4
// 千位和百位可以选00 01 02....22  十位可以取到1 个位可以选0-9  共有 23 * 10 中排列
// 当千位和百位取23,十位取1，个位可以去0-4 即 2310-2314共5个
// 即 23 *10 + 4 +1

// 计算公式为当前位置的    权重 * 高位 + 低位 + 1 =  23 * 10 + 4 + 1 = 235

// case 3: cur>1 即2-9
// 2  3  2  4
// 千位和百位可以选00 01 02....22  十位可以取到1(形如 [00|01...|22]1[0-9] 都是<2324) 个位可以选0-9  共有 23 * 10 中排列
// 当千位和百位取23,十位取1，个位可以去0-9 即 2310-2319共10个 （其中2311，被计算了两次，分别是从个位和十位分析得到的1次）
//    即 23 *10 + 10

// 计算公式为当前位置的    权重 * ( 高位  + 1 ) =  240



// 变量的初始化

// higt = n / 10
// cur  = n % 10
// low  = 0
// pow = 1 个位



// 当高位和当前位置同时为0 的时候，说明应该是退出循环


// while( high !== 0 || cur !== 0) {
//   low += cur * pow;  // 低位应该从个位开始累积
//   cur = high / 10;
//   high = high / 10;
//   pow = pow * 10;
// }

function fun(n) {
  let high = Math.floor(n / 10) , cur  = n % 10, low  = 0, pow = 1 , result = 0;

  while( high !== 0 || cur !== 0) {

    // 使用公式
    if(cur === 0) {
      result += pow * high
    } else if (cur === 1) {
      result += pow * high + low + 1;
    } else {
      result += (high + 1) * pow;
    }


    low += cur * pow;  // 低位应该从个位开始累积
    cur = high % 10;
    high =  Math.floor(high / 10);
    pow = pow * 10;
  }

  return result;
}


console.log(fun(13));
