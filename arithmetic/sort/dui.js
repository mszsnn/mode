
// 堆排序算法的特性
/*堆排序算法的特性将数组看成是一个完全二叉树
1 将树构建为大顶堆， 就是节点的树都大于等于叶子节点， 或者小于等于叶子节点
2 将树的顶点，和最后一个元素交换，就得到了最大或者最小值
3 除了最后一个，继续调整剩下的树，这样就能得到第二大的树，依次类推，就能得到完整的排序*/


// 长度为len 的非叶子节点的最后一个节点  len/2 - 1
// 节点和子节点   a[i]   左节点 a[2 * i] + 1  和 右节点a[2 * i] + 2



function adjustHeap(arr,i,len){
  // 这个方法用来进行定点， 叶子页节点的大小和位置调整， 仅仅设计节点和叶子节点，以及叶子节点的下属，
  // 因为有可能调整高层节点的时候，影响到了底下节点构成大顶堆的必要条件

  // i 为要操作的非叶子节点， 叶子节点为 2* i + 1   2*i + 2
  let temp = arr[i]; // 现在的定点
  // 从现在的定点到叶子节点的叶子
  for(let j = 2 * i + 1; j < len ; j = j * 2 + 1) {
    let left = arr[j];
    let right = arr[j + 1];

    if (j + 1 < len && left < right) {
      j++; // 这部是因为如果左叶子节点小于右叶子节点， 那么可能调整的肯定是有叶子节点
      // 所以就仅仅操作右边叶子节点的叶子
    }

    // 和定点进行比较  arr[j] 是两个叶子节点里面比较大的那个
    if (temp < arr[j]) {
      [arr[i], arr[j]] = [arr[j], arr[i]]
      // 定点得更换，交换了之后， 定点需要更新
      i = j;
    } else {
      break;
    }
  }

}
function heapSort(data) {
  //构造大顶堆
  //此时我们从最后一个非叶子结点开始,叶结点自然不用调整

  // 这样能得到一个大顶堆
  for (let i = Math.floor(data.length / 2) - 1; i >=0 ; i--) {
    adjustHeap(data, i, data.length)
  }

  // 交换第一个和最后一个元素， 然后忽略最后一个元素 ，重新进行大顶堆排序

  // 从后面往前进行赋值
  for (let k = data.length - 1 ; k > 0 ; k--) {

    [data[0], data[k]] = [data[k], data[0]]

    // 整个元素的位置已经调整好了， 仅仅需要调整定点的大小就行
    adjustHeap(data, 0, k)
  }

}


const arr = [2, 1, 9, 7, 9, 7, 10];
heapSort(arr);
console.log(arr);
